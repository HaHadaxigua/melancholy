// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/HaHadaxigua/melancholy/ent/exitlog"
	"github.com/HaHadaxigua/melancholy/ent/folder"
	"github.com/HaHadaxigua/melancholy/ent/mfile"
	"github.com/HaHadaxigua/melancholy/ent/predicate"
	"github.com/HaHadaxigua/melancholy/ent/role"
	"github.com/HaHadaxigua/melancholy/ent/user"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeExitLog = "ExitLog"
	TypeFolder  = "Folder"
	TypeMFile   = "MFile"
	TypeRole    = "Role"
	TypeUser    = "User"
)

// ExitLogMutation represents an operation that mutate the ExitLogs
// nodes in the graph.
type ExitLogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *int
	adduser_id    *int
	token         *string
	date          *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ExitLog, error)
	predicates    []predicate.ExitLog
}

var _ ent.Mutation = (*ExitLogMutation)(nil)

// exitlogOption allows to manage the mutation configuration using functional options.
type exitlogOption func(*ExitLogMutation)

// newExitLogMutation creates new mutation for $n.Name.
func newExitLogMutation(c config, op Op, opts ...exitlogOption) *ExitLogMutation {
	m := &ExitLogMutation{
		config:        c,
		op:            op,
		typ:           TypeExitLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExitLogID sets the id field of the mutation.
func withExitLogID(id int) exitlogOption {
	return func(m *ExitLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ExitLog
		)
		m.oldValue = func(ctx context.Context) (*ExitLog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ExitLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExitLog sets the old ExitLog of the mutation.
func withExitLog(node *ExitLog) exitlogOption {
	return func(m *ExitLogMutation) {
		m.oldValue = func(context.Context) (*ExitLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExitLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExitLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on ExitLog creation.
func (m *ExitLogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ExitLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the user_id field.
func (m *ExitLogMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the user_id value in the mutation.
func (m *ExitLogMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old user_id value of the ExitLog.
// If the ExitLog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExitLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to user_id.
func (m *ExitLogMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the user_id field in this mutation.
func (m *ExitLogMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID reset all changes of the "user_id" field.
func (m *ExitLogMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetToken sets the token field.
func (m *ExitLogMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the token value in the mutation.
func (m *ExitLogMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old token value of the ExitLog.
// If the ExitLog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExitLogMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToken is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken reset all changes of the "token" field.
func (m *ExitLogMutation) ResetToken() {
	m.token = nil
}

// SetDate sets the date field.
func (m *ExitLogMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the date value in the mutation.
func (m *ExitLogMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the ExitLog.
// If the ExitLog object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExitLogMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate reset all changes of the "date" field.
func (m *ExitLogMutation) ResetDate() {
	m.date = nil
}

// Op returns the operation name.
func (m *ExitLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ExitLog).
func (m *ExitLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ExitLogMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user_id != nil {
		fields = append(fields, exitlog.FieldUserID)
	}
	if m.token != nil {
		fields = append(fields, exitlog.FieldToken)
	}
	if m.date != nil {
		fields = append(fields, exitlog.FieldDate)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ExitLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exitlog.FieldUserID:
		return m.UserID()
	case exitlog.FieldToken:
		return m.Token()
	case exitlog.FieldDate:
		return m.Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ExitLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exitlog.FieldUserID:
		return m.OldUserID(ctx)
	case exitlog.FieldToken:
		return m.OldToken(ctx)
	case exitlog.FieldDate:
		return m.OldDate(ctx)
	}
	return nil, fmt.Errorf("unknown ExitLog field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExitLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exitlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case exitlog.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case exitlog.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	}
	return fmt.Errorf("unknown ExitLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ExitLogMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, exitlog.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ExitLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exitlog.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExitLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exitlog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown ExitLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ExitLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ExitLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExitLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ExitLog nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ExitLogMutation) ResetField(name string) error {
	switch name {
	case exitlog.FieldUserID:
		m.ResetUserID()
		return nil
	case exitlog.FieldToken:
		m.ResetToken()
		return nil
	case exitlog.FieldDate:
		m.ResetDate()
		return nil
	}
	return fmt.Errorf("unknown ExitLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ExitLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ExitLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ExitLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ExitLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ExitLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ExitLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ExitLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ExitLog unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ExitLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ExitLog edge %s", name)
}

// FolderMutation represents an operation that mutate the Folders
// nodes in the graph.
type FolderMutation struct {
	config
	op            Op
	typ           string
	id            *int
	parent        *int
	addparent     *int
	_path         *string
	name          *string
	author        *int
	addauthor     *int
	size          *int
	addsize       *int
	status        *folder.Status
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	mfiles        map[int]struct{}
	removedmfiles map[int]struct{}
	clearedmfiles bool
	p             *int
	clearedp      bool
	c             map[int]struct{}
	removedc      map[int]struct{}
	clearedc      bool
	done          bool
	oldValue      func(context.Context) (*Folder, error)
	predicates    []predicate.Folder
}

var _ ent.Mutation = (*FolderMutation)(nil)

// folderOption allows to manage the mutation configuration using functional options.
type folderOption func(*FolderMutation)

// newFolderMutation creates new mutation for $n.Name.
func newFolderMutation(c config, op Op, opts ...folderOption) *FolderMutation {
	m := &FolderMutation{
		config:        c,
		op:            op,
		typ:           TypeFolder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFolderID sets the id field of the mutation.
func withFolderID(id int) folderOption {
	return func(m *FolderMutation) {
		var (
			err   error
			once  sync.Once
			value *Folder
		)
		m.oldValue = func(ctx context.Context) (*Folder, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Folder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFolder sets the old Folder of the mutation.
func withFolder(node *Folder) folderOption {
	return func(m *FolderMutation) {
		m.oldValue = func(context.Context) (*Folder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FolderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FolderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Folder creation.
func (m *FolderMutation) SetID(id int) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FolderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetParent sets the parent field.
func (m *FolderMutation) SetParent(i int) {
	m.parent = &i
	m.addparent = nil
}

// Parent returns the parent value in the mutation.
func (m *FolderMutation) Parent() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParent returns the old parent value of the Folder.
// If the Folder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FolderMutation) OldParent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParent is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParent: %w", err)
	}
	return oldValue.Parent, nil
}

// AddParent adds i to parent.
func (m *FolderMutation) AddParent(i int) {
	if m.addparent != nil {
		*m.addparent += i
	} else {
		m.addparent = &i
	}
}

// AddedParent returns the value that was added to the parent field in this mutation.
func (m *FolderMutation) AddedParent() (r int, exists bool) {
	v := m.addparent
	if v == nil {
		return
	}
	return *v, true
}

// ResetParent reset all changes of the "parent" field.
func (m *FolderMutation) ResetParent() {
	m.parent = nil
	m.addparent = nil
}

// SetPath sets the path field.
func (m *FolderMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the path value in the mutation.
func (m *FolderMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old path value of the Folder.
// If the Folder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FolderMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath reset all changes of the "path" field.
func (m *FolderMutation) ResetPath() {
	m._path = nil
}

// SetName sets the name field.
func (m *FolderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FolderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Folder.
// If the Folder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FolderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FolderMutation) ResetName() {
	m.name = nil
}

// SetAuthor sets the author field.
func (m *FolderMutation) SetAuthor(i int) {
	m.author = &i
	m.addauthor = nil
}

// Author returns the author value in the mutation.
func (m *FolderMutation) Author() (r int, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old author value of the Folder.
// If the Folder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FolderMutation) OldAuthor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// AddAuthor adds i to author.
func (m *FolderMutation) AddAuthor(i int) {
	if m.addauthor != nil {
		*m.addauthor += i
	} else {
		m.addauthor = &i
	}
}

// AddedAuthor returns the value that was added to the author field in this mutation.
func (m *FolderMutation) AddedAuthor() (r int, exists bool) {
	v := m.addauthor
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthor reset all changes of the "author" field.
func (m *FolderMutation) ResetAuthor() {
	m.author = nil
	m.addauthor = nil
}

// SetSize sets the size field.
func (m *FolderMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the size value in the mutation.
func (m *FolderMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old size value of the Folder.
// If the Folder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FolderMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSize is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to size.
func (m *FolderMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the size field in this mutation.
func (m *FolderMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of size.
func (m *FolderMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[folder.FieldSize] = struct{}{}
}

// SizeCleared returns if the field size was cleared in this mutation.
func (m *FolderMutation) SizeCleared() bool {
	_, ok := m.clearedFields[folder.FieldSize]
	return ok
}

// ResetSize reset all changes of the "size" field.
func (m *FolderMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, folder.FieldSize)
}

// SetStatus sets the status field.
func (m *FolderMutation) SetStatus(f folder.Status) {
	m.status = &f
}

// Status returns the status value in the mutation.
func (m *FolderMutation) Status() (r folder.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Folder.
// If the Folder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FolderMutation) OldStatus(ctx context.Context) (v folder.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *FolderMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the created_at field.
func (m *FolderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *FolderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Folder.
// If the Folder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FolderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *FolderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *FolderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *FolderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Folder.
// If the Folder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FolderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *FolderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *FolderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *FolderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the Folder.
// If the Folder object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FolderMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *FolderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[folder.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *FolderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[folder.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *FolderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, folder.FieldDeletedAt)
}

// AddMfileIDs adds the mfiles edge to MFile by ids.
func (m *FolderMutation) AddMfileIDs(ids ...int) {
	if m.mfiles == nil {
		m.mfiles = make(map[int]struct{})
	}
	for i := range ids {
		m.mfiles[ids[i]] = struct{}{}
	}
}

// ClearMfiles clears the mfiles edge to MFile.
func (m *FolderMutation) ClearMfiles() {
	m.clearedmfiles = true
}

// MfilesCleared returns if the edge mfiles was cleared.
func (m *FolderMutation) MfilesCleared() bool {
	return m.clearedmfiles
}

// RemoveMfileIDs removes the mfiles edge to MFile by ids.
func (m *FolderMutation) RemoveMfileIDs(ids ...int) {
	if m.removedmfiles == nil {
		m.removedmfiles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmfiles[ids[i]] = struct{}{}
	}
}

// RemovedMfiles returns the removed ids of mfiles.
func (m *FolderMutation) RemovedMfilesIDs() (ids []int) {
	for id := range m.removedmfiles {
		ids = append(ids, id)
	}
	return
}

// MfilesIDs returns the mfiles ids in the mutation.
func (m *FolderMutation) MfilesIDs() (ids []int) {
	for id := range m.mfiles {
		ids = append(ids, id)
	}
	return
}

// ResetMfiles reset all changes of the "mfiles" edge.
func (m *FolderMutation) ResetMfiles() {
	m.mfiles = nil
	m.clearedmfiles = false
	m.removedmfiles = nil
}

// SetPID sets the p edge to Folder by id.
func (m *FolderMutation) SetPID(id int) {
	m.p = &id
}

// ClearP clears the p edge to Folder.
func (m *FolderMutation) ClearP() {
	m.clearedp = true
}

// PCleared returns if the edge p was cleared.
func (m *FolderMutation) PCleared() bool {
	return m.clearedp
}

// PID returns the p id in the mutation.
func (m *FolderMutation) PID() (id int, exists bool) {
	if m.p != nil {
		return *m.p, true
	}
	return
}

// PIDs returns the p ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PID instead. It exists only for internal usage by the builders.
func (m *FolderMutation) PIDs() (ids []int) {
	if id := m.p; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetP reset all changes of the "p" edge.
func (m *FolderMutation) ResetP() {
	m.p = nil
	m.clearedp = false
}

// AddCIDs adds the c edge to Folder by ids.
func (m *FolderMutation) AddCIDs(ids ...int) {
	if m.c == nil {
		m.c = make(map[int]struct{})
	}
	for i := range ids {
		m.c[ids[i]] = struct{}{}
	}
}

// ClearC clears the c edge to Folder.
func (m *FolderMutation) ClearC() {
	m.clearedc = true
}

// CCleared returns if the edge c was cleared.
func (m *FolderMutation) CCleared() bool {
	return m.clearedc
}

// RemoveCIDs removes the c edge to Folder by ids.
func (m *FolderMutation) RemoveCIDs(ids ...int) {
	if m.removedc == nil {
		m.removedc = make(map[int]struct{})
	}
	for i := range ids {
		m.removedc[ids[i]] = struct{}{}
	}
}

// RemovedC returns the removed ids of c.
func (m *FolderMutation) RemovedCIDs() (ids []int) {
	for id := range m.removedc {
		ids = append(ids, id)
	}
	return
}

// CIDs returns the c ids in the mutation.
func (m *FolderMutation) CIDs() (ids []int) {
	for id := range m.c {
		ids = append(ids, id)
	}
	return
}

// ResetC reset all changes of the "c" edge.
func (m *FolderMutation) ResetC() {
	m.c = nil
	m.clearedc = false
	m.removedc = nil
}

// Op returns the operation name.
func (m *FolderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Folder).
func (m *FolderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FolderMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.parent != nil {
		fields = append(fields, folder.FieldParent)
	}
	if m._path != nil {
		fields = append(fields, folder.FieldPath)
	}
	if m.name != nil {
		fields = append(fields, folder.FieldName)
	}
	if m.author != nil {
		fields = append(fields, folder.FieldAuthor)
	}
	if m.size != nil {
		fields = append(fields, folder.FieldSize)
	}
	if m.status != nil {
		fields = append(fields, folder.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, folder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, folder.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, folder.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FolderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case folder.FieldParent:
		return m.Parent()
	case folder.FieldPath:
		return m.Path()
	case folder.FieldName:
		return m.Name()
	case folder.FieldAuthor:
		return m.Author()
	case folder.FieldSize:
		return m.Size()
	case folder.FieldStatus:
		return m.Status()
	case folder.FieldCreatedAt:
		return m.CreatedAt()
	case folder.FieldUpdatedAt:
		return m.UpdatedAt()
	case folder.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FolderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case folder.FieldParent:
		return m.OldParent(ctx)
	case folder.FieldPath:
		return m.OldPath(ctx)
	case folder.FieldName:
		return m.OldName(ctx)
	case folder.FieldAuthor:
		return m.OldAuthor(ctx)
	case folder.FieldSize:
		return m.OldSize(ctx)
	case folder.FieldStatus:
		return m.OldStatus(ctx)
	case folder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case folder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case folder.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Folder field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FolderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case folder.FieldParent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParent(v)
		return nil
	case folder.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case folder.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case folder.FieldAuthor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case folder.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case folder.FieldStatus:
		v, ok := value.(folder.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case folder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case folder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case folder.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Folder field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FolderMutation) AddedFields() []string {
	var fields []string
	if m.addparent != nil {
		fields = append(fields, folder.FieldParent)
	}
	if m.addauthor != nil {
		fields = append(fields, folder.FieldAuthor)
	}
	if m.addsize != nil {
		fields = append(fields, folder.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FolderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case folder.FieldParent:
		return m.AddedParent()
	case folder.FieldAuthor:
		return m.AddedAuthor()
	case folder.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FolderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case folder.FieldParent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParent(v)
		return nil
	case folder.FieldAuthor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthor(v)
		return nil
	case folder.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Folder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FolderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(folder.FieldSize) {
		fields = append(fields, folder.FieldSize)
	}
	if m.FieldCleared(folder.FieldDeletedAt) {
		fields = append(fields, folder.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FolderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FolderMutation) ClearField(name string) error {
	switch name {
	case folder.FieldSize:
		m.ClearSize()
		return nil
	case folder.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Folder nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FolderMutation) ResetField(name string) error {
	switch name {
	case folder.FieldParent:
		m.ResetParent()
		return nil
	case folder.FieldPath:
		m.ResetPath()
		return nil
	case folder.FieldName:
		m.ResetName()
		return nil
	case folder.FieldAuthor:
		m.ResetAuthor()
		return nil
	case folder.FieldSize:
		m.ResetSize()
		return nil
	case folder.FieldStatus:
		m.ResetStatus()
		return nil
	case folder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case folder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case folder.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Folder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FolderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.mfiles != nil {
		edges = append(edges, folder.EdgeMfiles)
	}
	if m.p != nil {
		edges = append(edges, folder.EdgeP)
	}
	if m.c != nil {
		edges = append(edges, folder.EdgeC)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FolderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case folder.EdgeMfiles:
		ids := make([]ent.Value, 0, len(m.mfiles))
		for id := range m.mfiles {
			ids = append(ids, id)
		}
		return ids
	case folder.EdgeP:
		if id := m.p; id != nil {
			return []ent.Value{*id}
		}
	case folder.EdgeC:
		ids := make([]ent.Value, 0, len(m.c))
		for id := range m.c {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FolderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmfiles != nil {
		edges = append(edges, folder.EdgeMfiles)
	}
	if m.removedc != nil {
		edges = append(edges, folder.EdgeC)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FolderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case folder.EdgeMfiles:
		ids := make([]ent.Value, 0, len(m.removedmfiles))
		for id := range m.removedmfiles {
			ids = append(ids, id)
		}
		return ids
	case folder.EdgeC:
		ids := make([]ent.Value, 0, len(m.removedc))
		for id := range m.removedc {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FolderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmfiles {
		edges = append(edges, folder.EdgeMfiles)
	}
	if m.clearedp {
		edges = append(edges, folder.EdgeP)
	}
	if m.clearedc {
		edges = append(edges, folder.EdgeC)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FolderMutation) EdgeCleared(name string) bool {
	switch name {
	case folder.EdgeMfiles:
		return m.clearedmfiles
	case folder.EdgeP:
		return m.clearedp
	case folder.EdgeC:
		return m.clearedc
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FolderMutation) ClearEdge(name string) error {
	switch name {
	case folder.EdgeP:
		m.ClearP()
		return nil
	}
	return fmt.Errorf("unknown Folder unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FolderMutation) ResetEdge(name string) error {
	switch name {
	case folder.EdgeMfiles:
		m.ResetMfiles()
		return nil
	case folder.EdgeP:
		m.ResetP()
		return nil
	case folder.EdgeC:
		m.ResetC()
		return nil
	}
	return fmt.Errorf("unknown Folder edge %s", name)
}

// MFileMutation represents an operation that mutate the MFiles
// nodes in the graph.
type MFileMutation struct {
	config
	op            Op
	typ           string
	id            *int
	parent        *int
	addparent     *int
	name          *string
	author        *int
	addauthor     *int
	md5           *int
	addmd5        *int
	size          *int
	addsize       *int
	_MType        *mfile.MType
	desc          *string
	status        *mfile.Status
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	folder        *int
	clearedfolder bool
	done          bool
	oldValue      func(context.Context) (*MFile, error)
	predicates    []predicate.MFile
}

var _ ent.Mutation = (*MFileMutation)(nil)

// mfileOption allows to manage the mutation configuration using functional options.
type mfileOption func(*MFileMutation)

// newMFileMutation creates new mutation for $n.Name.
func newMFileMutation(c config, op Op, opts ...mfileOption) *MFileMutation {
	m := &MFileMutation{
		config:        c,
		op:            op,
		typ:           TypeMFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMFileID sets the id field of the mutation.
func withMFileID(id int) mfileOption {
	return func(m *MFileMutation) {
		var (
			err   error
			once  sync.Once
			value *MFile
		)
		m.oldValue = func(ctx context.Context) (*MFile, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMFile sets the old MFile of the mutation.
func withMFile(node *MFile) mfileOption {
	return func(m *MFileMutation) {
		m.oldValue = func(context.Context) (*MFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on MFile creation.
func (m *MFileMutation) SetID(id int) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MFileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetParent sets the parent field.
func (m *MFileMutation) SetParent(i int) {
	m.parent = &i
	m.addparent = nil
}

// Parent returns the parent value in the mutation.
func (m *MFileMutation) Parent() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParent returns the old parent value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldParent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParent is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParent: %w", err)
	}
	return oldValue.Parent, nil
}

// AddParent adds i to parent.
func (m *MFileMutation) AddParent(i int) {
	if m.addparent != nil {
		*m.addparent += i
	} else {
		m.addparent = &i
	}
}

// AddedParent returns the value that was added to the parent field in this mutation.
func (m *MFileMutation) AddedParent() (r int, exists bool) {
	v := m.addparent
	if v == nil {
		return
	}
	return *v, true
}

// ResetParent reset all changes of the "parent" field.
func (m *MFileMutation) ResetParent() {
	m.parent = nil
	m.addparent = nil
}

// SetName sets the name field.
func (m *MFileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MFileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MFileMutation) ResetName() {
	m.name = nil
}

// SetAuthor sets the author field.
func (m *MFileMutation) SetAuthor(i int) {
	m.author = &i
	m.addauthor = nil
}

// Author returns the author value in the mutation.
func (m *MFileMutation) Author() (r int, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old author value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldAuthor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// AddAuthor adds i to author.
func (m *MFileMutation) AddAuthor(i int) {
	if m.addauthor != nil {
		*m.addauthor += i
	} else {
		m.addauthor = &i
	}
}

// AddedAuthor returns the value that was added to the author field in this mutation.
func (m *MFileMutation) AddedAuthor() (r int, exists bool) {
	v := m.addauthor
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthor reset all changes of the "author" field.
func (m *MFileMutation) ResetAuthor() {
	m.author = nil
	m.addauthor = nil
}

// SetMd5 sets the md5 field.
func (m *MFileMutation) SetMd5(i int) {
	m.md5 = &i
	m.addmd5 = nil
}

// Md5 returns the md5 value in the mutation.
func (m *MFileMutation) Md5() (r int, exists bool) {
	v := m.md5
	if v == nil {
		return
	}
	return *v, true
}

// OldMd5 returns the old md5 value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldMd5(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMd5 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMd5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMd5: %w", err)
	}
	return oldValue.Md5, nil
}

// AddMd5 adds i to md5.
func (m *MFileMutation) AddMd5(i int) {
	if m.addmd5 != nil {
		*m.addmd5 += i
	} else {
		m.addmd5 = &i
	}
}

// AddedMd5 returns the value that was added to the md5 field in this mutation.
func (m *MFileMutation) AddedMd5() (r int, exists bool) {
	v := m.addmd5
	if v == nil {
		return
	}
	return *v, true
}

// ResetMd5 reset all changes of the "md5" field.
func (m *MFileMutation) ResetMd5() {
	m.md5 = nil
	m.addmd5 = nil
}

// SetSize sets the size field.
func (m *MFileMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the size value in the mutation.
func (m *MFileMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old size value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSize is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to size.
func (m *MFileMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the size field in this mutation.
func (m *MFileMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of size.
func (m *MFileMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[mfile.FieldSize] = struct{}{}
}

// SizeCleared returns if the field size was cleared in this mutation.
func (m *MFileMutation) SizeCleared() bool {
	_, ok := m.clearedFields[mfile.FieldSize]
	return ok
}

// ResetSize reset all changes of the "size" field.
func (m *MFileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, mfile.FieldSize)
}

// SetMType sets the MType field.
func (m *MFileMutation) SetMType(mt mfile.MType) {
	m._MType = &mt
}

// MType returns the MType value in the mutation.
func (m *MFileMutation) MType() (r mfile.MType, exists bool) {
	v := m._MType
	if v == nil {
		return
	}
	return *v, true
}

// OldMType returns the old MType value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldMType(ctx context.Context) (v mfile.MType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMType: %w", err)
	}
	return oldValue.MType, nil
}

// ResetMType reset all changes of the "MType" field.
func (m *MFileMutation) ResetMType() {
	m._MType = nil
}

// SetDesc sets the desc field.
func (m *MFileMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the desc value in the mutation.
func (m *MFileMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old desc value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDesc is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of desc.
func (m *MFileMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[mfile.FieldDesc] = struct{}{}
}

// DescCleared returns if the field desc was cleared in this mutation.
func (m *MFileMutation) DescCleared() bool {
	_, ok := m.clearedFields[mfile.FieldDesc]
	return ok
}

// ResetDesc reset all changes of the "desc" field.
func (m *MFileMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, mfile.FieldDesc)
}

// SetStatus sets the status field.
func (m *MFileMutation) SetStatus(value mfile.Status) {
	m.status = &value
}

// Status returns the status value in the mutation.
func (m *MFileMutation) Status() (r mfile.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldStatus(ctx context.Context) (v mfile.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *MFileMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the created_at field.
func (m *MFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *MFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *MFileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *MFileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the MFile.
// If the MFile object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MFileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *MFileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[mfile.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *MFileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[mfile.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *MFileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, mfile.FieldDeletedAt)
}

// SetFolderID sets the folder edge to Folder by id.
func (m *MFileMutation) SetFolderID(id int) {
	m.folder = &id
}

// ClearFolder clears the folder edge to Folder.
func (m *MFileMutation) ClearFolder() {
	m.clearedfolder = true
}

// FolderCleared returns if the edge folder was cleared.
func (m *MFileMutation) FolderCleared() bool {
	return m.clearedfolder
}

// FolderID returns the folder id in the mutation.
func (m *MFileMutation) FolderID() (id int, exists bool) {
	if m.folder != nil {
		return *m.folder, true
	}
	return
}

// FolderIDs returns the folder ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FolderID instead. It exists only for internal usage by the builders.
func (m *MFileMutation) FolderIDs() (ids []int) {
	if id := m.folder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFolder reset all changes of the "folder" edge.
func (m *MFileMutation) ResetFolder() {
	m.folder = nil
	m.clearedfolder = false
}

// Op returns the operation name.
func (m *MFileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MFile).
func (m *MFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MFileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.parent != nil {
		fields = append(fields, mfile.FieldParent)
	}
	if m.name != nil {
		fields = append(fields, mfile.FieldName)
	}
	if m.author != nil {
		fields = append(fields, mfile.FieldAuthor)
	}
	if m.md5 != nil {
		fields = append(fields, mfile.FieldMd5)
	}
	if m.size != nil {
		fields = append(fields, mfile.FieldSize)
	}
	if m._MType != nil {
		fields = append(fields, mfile.FieldMType)
	}
	if m.desc != nil {
		fields = append(fields, mfile.FieldDesc)
	}
	if m.status != nil {
		fields = append(fields, mfile.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, mfile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mfile.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, mfile.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mfile.FieldParent:
		return m.Parent()
	case mfile.FieldName:
		return m.Name()
	case mfile.FieldAuthor:
		return m.Author()
	case mfile.FieldMd5:
		return m.Md5()
	case mfile.FieldSize:
		return m.Size()
	case mfile.FieldMType:
		return m.MType()
	case mfile.FieldDesc:
		return m.Desc()
	case mfile.FieldStatus:
		return m.Status()
	case mfile.FieldCreatedAt:
		return m.CreatedAt()
	case mfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case mfile.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mfile.FieldParent:
		return m.OldParent(ctx)
	case mfile.FieldName:
		return m.OldName(ctx)
	case mfile.FieldAuthor:
		return m.OldAuthor(ctx)
	case mfile.FieldMd5:
		return m.OldMd5(ctx)
	case mfile.FieldSize:
		return m.OldSize(ctx)
	case mfile.FieldMType:
		return m.OldMType(ctx)
	case mfile.FieldDesc:
		return m.OldDesc(ctx)
	case mfile.FieldStatus:
		return m.OldStatus(ctx)
	case mfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mfile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MFile field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mfile.FieldParent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParent(v)
		return nil
	case mfile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mfile.FieldAuthor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case mfile.FieldMd5:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMd5(v)
		return nil
	case mfile.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case mfile.FieldMType:
		v, ok := value.(mfile.MType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMType(v)
		return nil
	case mfile.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case mfile.FieldStatus:
		v, ok := value.(mfile.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mfile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MFileMutation) AddedFields() []string {
	var fields []string
	if m.addparent != nil {
		fields = append(fields, mfile.FieldParent)
	}
	if m.addauthor != nil {
		fields = append(fields, mfile.FieldAuthor)
	}
	if m.addmd5 != nil {
		fields = append(fields, mfile.FieldMd5)
	}
	if m.addsize != nil {
		fields = append(fields, mfile.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mfile.FieldParent:
		return m.AddedParent()
	case mfile.FieldAuthor:
		return m.AddedAuthor()
	case mfile.FieldMd5:
		return m.AddedMd5()
	case mfile.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mfile.FieldParent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParent(v)
		return nil
	case mfile.FieldAuthor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthor(v)
		return nil
	case mfile.FieldMd5:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMd5(v)
		return nil
	case mfile.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown MFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mfile.FieldSize) {
		fields = append(fields, mfile.FieldSize)
	}
	if m.FieldCleared(mfile.FieldDesc) {
		fields = append(fields, mfile.FieldDesc)
	}
	if m.FieldCleared(mfile.FieldDeletedAt) {
		fields = append(fields, mfile.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MFileMutation) ClearField(name string) error {
	switch name {
	case mfile.FieldSize:
		m.ClearSize()
		return nil
	case mfile.FieldDesc:
		m.ClearDesc()
		return nil
	case mfile.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown MFile nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MFileMutation) ResetField(name string) error {
	switch name {
	case mfile.FieldParent:
		m.ResetParent()
		return nil
	case mfile.FieldName:
		m.ResetName()
		return nil
	case mfile.FieldAuthor:
		m.ResetAuthor()
		return nil
	case mfile.FieldMd5:
		m.ResetMd5()
		return nil
	case mfile.FieldSize:
		m.ResetSize()
		return nil
	case mfile.FieldMType:
		m.ResetMType()
		return nil
	case mfile.FieldDesc:
		m.ResetDesc()
		return nil
	case mfile.FieldStatus:
		m.ResetStatus()
		return nil
	case mfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mfile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown MFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.folder != nil {
		edges = append(edges, mfile.EdgeFolder)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mfile.EdgeFolder:
		if id := m.folder; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MFileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfolder {
		edges = append(edges, mfile.EdgeFolder)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MFileMutation) EdgeCleared(name string) bool {
	switch name {
	case mfile.EdgeFolder:
		return m.clearedfolder
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MFileMutation) ClearEdge(name string) error {
	switch name {
	case mfile.EdgeFolder:
		m.ClearFolder()
		return nil
	}
	return fmt.Errorf("unknown MFile unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MFileMutation) ResetEdge(name string) error {
	switch name {
	case mfile.EdgeFolder:
		m.ResetFolder()
		return nil
	}
	return fmt.Errorf("unknown MFile edge %s", name)
}

// RoleMutation represents an operation that mutate the Roles
// nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	status        *role.Status
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows to manage the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for $n.Name.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the id field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Role creation.
func (m *RoleMutation) SetID(id int) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the status field.
func (m *RoleMutation) SetStatus(r role.Status) {
	m.status = &r
}

// Status returns the status value in the mutation.
func (m *RoleMutation) Status() (r role.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v role.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the created_at field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the Role.
// If the Role object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// AddUserIDs adds the users edge to User by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the users edge to User.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared returns if the edge users was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the users edge to User by ids.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed ids of users.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the users ids in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers reset all changes of the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldStatus:
		return m.Status()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(role.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	username        *string
	password        *string
	phone           *int
	addphone        *int
	email           *string
	state           *user.State
	salt            *string
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	clearedFields   map[string]struct{}
	roles           map[int]struct{}
	removedroles    map[int]struct{}
	clearedroles    bool
	exitlogs        map[int]struct{}
	removedexitlogs map[int]struct{}
	clearedexitlogs bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on User creation.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUsername sets the username field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the username value in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old username value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername reset all changes of the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetPhone sets the phone field.
func (m *UserMutation) SetPhone(i int) {
	m.phone = &i
	m.addphone = nil
}

// Phone returns the phone value in the mutation.
func (m *UserMutation) Phone() (r int, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// AddPhone adds i to phone.
func (m *UserMutation) AddPhone(i int) {
	if m.addphone != nil {
		*m.addphone += i
	} else {
		m.addphone = &i
	}
}

// AddedPhone returns the value that was added to the phone field in this mutation.
func (m *UserMutation) AddedPhone() (r int, exists bool) {
	v := m.addphone
	if v == nil {
		return
	}
	return *v, true
}

// ClearPhone clears the value of phone.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.addphone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the field phone was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone reset all changes of the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	m.addphone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetState sets the state field.
func (m *UserMutation) SetState(u user.State) {
	m.state = &u
}

// State returns the state value in the mutation.
func (m *UserMutation) State() (r user.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old state value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldState(ctx context.Context) (v user.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState reset all changes of the "state" field.
func (m *UserMutation) ResetState() {
	m.state = nil
}

// SetSalt sets the salt field.
func (m *UserMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the salt value in the mutation.
func (m *UserMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old salt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt reset all changes of the "salt" field.
func (m *UserMutation) ResetSalt() {
	m.salt = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the deleted_at field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// AddRoleIDs adds the roles edge to Role by ids.
func (m *UserMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the roles edge to Role.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared returns if the edge roles was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the roles edge to Role by ids.
func (m *UserMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed ids of roles.
func (m *UserMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the roles ids in the mutation.
func (m *UserMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles reset all changes of the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddExitlogIDs adds the exitlogs edge to ExitLog by ids.
func (m *UserMutation) AddExitlogIDs(ids ...int) {
	if m.exitlogs == nil {
		m.exitlogs = make(map[int]struct{})
	}
	for i := range ids {
		m.exitlogs[ids[i]] = struct{}{}
	}
}

// ClearExitlogs clears the exitlogs edge to ExitLog.
func (m *UserMutation) ClearExitlogs() {
	m.clearedexitlogs = true
}

// ExitlogsCleared returns if the edge exitlogs was cleared.
func (m *UserMutation) ExitlogsCleared() bool {
	return m.clearedexitlogs
}

// RemoveExitlogIDs removes the exitlogs edge to ExitLog by ids.
func (m *UserMutation) RemoveExitlogIDs(ids ...int) {
	if m.removedexitlogs == nil {
		m.removedexitlogs = make(map[int]struct{})
	}
	for i := range ids {
		m.removedexitlogs[ids[i]] = struct{}{}
	}
}

// RemovedExitlogs returns the removed ids of exitlogs.
func (m *UserMutation) RemovedExitlogsIDs() (ids []int) {
	for id := range m.removedexitlogs {
		ids = append(ids, id)
	}
	return
}

// ExitlogsIDs returns the exitlogs ids in the mutation.
func (m *UserMutation) ExitlogsIDs() (ids []int) {
	for id := range m.exitlogs {
		ids = append(ids, id)
	}
	return
}

// ResetExitlogs reset all changes of the "exitlogs" edge.
func (m *UserMutation) ResetExitlogs() {
	m.exitlogs = nil
	m.clearedexitlogs = false
	m.removedexitlogs = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.state != nil {
		fields = append(fields, user.FieldState)
	}
	if m.salt != nil {
		fields = append(fields, user.FieldSalt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldEmail:
		return m.Email()
	case user.FieldState:
		return m.State()
	case user.FieldSalt:
		return m.Salt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldState:
		return m.OldState(ctx)
	case user.FieldSalt:
		return m.OldSalt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldState:
		v, ok := value.(user.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case user.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addphone != nil {
		fields = append(fields, user.FieldPhone)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPhone:
		return m.AddedPhone()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldPhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPhone(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldState:
		m.ResetState()
		return nil
	case user.FieldSalt:
		m.ResetSalt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.exitlogs != nil {
		edges = append(edges, user.EdgeExitlogs)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExitlogs:
		ids := make([]ent.Value, 0, len(m.exitlogs))
		for id := range m.exitlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedexitlogs != nil {
		edges = append(edges, user.EdgeExitlogs)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExitlogs:
		ids := make([]ent.Value, 0, len(m.removedexitlogs))
		for id := range m.removedexitlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedexitlogs {
		edges = append(edges, user.EdgeExitlogs)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeExitlogs:
		return m.clearedexitlogs
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeExitlogs:
		m.ResetExitlogs()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
